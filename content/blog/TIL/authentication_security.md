---
title: '[TIL] HTTPS, 해싱, 쿠키, 세션' (수정필요)
date: 2021-12-27 23:12:12
category: TIL
thumbnail: { thumbnailSrc }
draft: true
img: false
---

## HTTPS

### HTTPS란?

HTTPS는 HTTP + Secure인데 말 그대로 HTTP에 Secure(보안)이 붙은 것을 뜻함.

HTTP보다 안전하고, 데이터 제공자의 신원을 보장받을 수 있기 때문에 HTTPS를 써야 한다.

클라이언트는 서버에 데이터 요청을 하고 이후 받은 데이터를 이용해서 필요한 작업을 수행하기에, <u>요청 및 응답을 중간에서 가로채는 **중간자 공격**에 취약</u>하다.

데이터가 중간에 다른 도메인을 거쳐서 전달되기 때문에 서버가 `"해당 데이터는 https://example.com 도메인에서 제공되었습니다."`라는 추가 데이터를 응답 객체에 실어 보낸다면 <u>'중간자 공격'으로 인해 다른 도메인에서 데이터를 받은 클라이언트는 데이터를 제공한 도메인과 전달받은 내용의 도메인을 **비교**하여 '중간자 공격'이 존재하는지 아닌지 확인</u>할 수 있다.

### HTTPS의 특징

#### 암호화

- HTTP 프로토콜은 요청 및 응답을 탈취한다면 프로그램을 이용하여 해당 요청으로 전달되는 데이터의 내용을 확인 가능하다.
  반면 HTTPS 프로토콜은 암호화된 데이터를 주고받기 때문에, 중간에 인터넷 요청이 탈취되더라도 정확한 키로 복호화하기 전까진 어떤 내용인지 알 수 없다.

- 암호화 키와 복호화 키가 동일한 대칭 키가 아닌, 서로 다른 비대칭 키를 사용한다.

#### 인증서 (Certificate)

- 인증서는 데이터를 제공한 서버가 정말로 데이터를 보내 준 서버인지(Man-in-the-Middle이 아닌지) 확인하는 용도로 사용된다.

- 브라우저는 인증서에서 해당 인증서를 발급한 CA 정보를 확인하고 인증된 CA가 발급한 인증서가 아니라면 경고창을 띄워 서버와 연결이 안전하지 않다는 화면을 보여준다.

- 브라우저 주소창 왼쪽 자물쇠 모양을 클릭하면 인증서를 확인할 수 있다.

* 데이터가 중간에 다른 도메인을 거쳐서 전달되기 때문에 서버가 `"해당 데이터는 https://example.com 도메인에서 제공되었습니다."`라는 추가 데이터를 응답 객체에 실어 보낸다면 <u>'중간자 공격'으로 인해 다른 도메인에서 데이터를 받은 클라이언트는 인증서의 도메인과 응답객체의 도메인을 **비교**하여 '중간자 공격'이 존재하는지 아닌지 확인</u>할 수 있다.

## Hashing & Salt

### Hashing

- 임의의 길이를 가진 문자열을 알아볼 수 없도록 고정된 길이의 다른 문자열로 변환하는 것
- 해시 함수의 연산은 오래걸리면 안 된다.
- 모든 값은 고유한 해시 값을 가진다. (즉, 해시 함수는 순수 함수다)
- 역으로 되돌리는 것은 불가능하지만, 해시 함수는 순수 함수이기에 간단한 입력값이라면 **레인보우 테이블**로 복호화를 시도할 수 있다.
  - 이러한 점을 막기 위해 후술할 Salt 개념이 생기게 되었다.
- 아주 작은 변경이라도 완전히 다른 해시 값을 가져야 한다.

  - `'password'` : _"4h3hg248hg0wh34hr8gh2fg434t92"_
  - `'passwold'` : _"3h14hg34h10fvmq44h24hvr894f4d"_

- 해시함수 종류 : MD5, SHA-1, SHA-2(SHA-256) 등

### Salt

- 해쉬 결과를 다르게 하기 위해 암호화할 원본 문자열에 추가하는 임의로 약속된 **'별도의 문자열(안전 장치)'**
  - 기존 : (암호화할 문자열) => hash 값
  - Salt 사용 : (암호화할 문자열) + (Salt) => hash 값

* **Salt**는,
  - 절대 재사용 금물
  - DB의 유저 테이블에 같이 저장
  - 유저와 패스워드 별로 유일한 값을 가져야 함
  - 사용자 계정을 생성할 때와 비밀번호를 변경할 때 새로운 Salt를 사용해야 함

## 쿠키 & 세션

### 쿠키

- 쿠키는 HTTPS의 stateless 특징을 보완한다.
  - Stateless : 각각의 요청은 서로 독립적. 이전 상태를 기억하지 않음.
- 쿠키에 저장된 정보를 통해 이전 상태를 알 수 있게 되어 독립된 요청들을 연결할 수 있다.
- 쿠키 정보는 클라이언트에서 열어볼 수 있기때문에 보안으로 활용할 수 없다.
  - 개발자 도구 -> Application -> Cookies
- 토큰을 사용할 땐 쿠키에 저장하지만 암호화된 형태로 저장하기 때문에 보안에 사용할 수 있다.
- 서버는 응답 헤더 (set-cookie) 를 통해 브라우저에 일방적으로 쿠키를 저장할 수 있다. 하지만 요즘은 법적으로 쿠키 설정 허용 메시지를 띄우도록 강제하는 추세.

#### 쿠키의 유즈케이스

- 로그인 상태 유지
- 검색어 저장
- 오늘 하루 동안 보지 않기 등

#### 쿠키 옵션

- httpOnly : 웹 서버를 통해서만 쿠키 접근 가능 (자바스크립트로 접근 차단)
- secure : HTTPS 통신일 경우만 쿠키를 서버로 전송
- sameSite : 디폴트는 Lax
  - strict : 사이트가 서로 다르면 쿠키 전송 불가
  - lax : 사이트가 서로 달라도 GET요청은 쿠키 전송 가능
  - none : 사이트가 달라도 모든 요청에 쿠키 전송 가능 (비추천, CSRF에 취약)

* sameSite가 none일 때, secure는 항상 true여야 함 (HTTPS에서만 쓸 수 있음)
* expires : 만료 날짜 (GMT) / maxAge : 쿠키 수명 (ms)
* path : 해당 디렉토리 + 하위 디렉토리에서만 쿠키 활성화
* domain : 쿠키가 활성화될 도메인

### 세션

- 컴퓨터와 사용자 간의 대화 / 송수신 연결 상태
- 연결이 되면 (인증 성공 시) 브라우저와 서버가 서로 session id를 가지고 있고 이를 비교하여 사용한다.
