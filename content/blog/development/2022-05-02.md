---
title: '[TS] Why Typescript?'
date: 2022-05-02 13:05:26
category: development
thumbnail: 'ts'
draft: false
img: false
---

: <u>**타입 안정성(Type Safety)** 때문</u>이다. TS 덕분에 실제 유저에게도 불쾌한 경험을 유발하는 런타임 에러를 포함한 모든 버그를 획기적으로 줄일 수 있고, 덕분에 생산성이 무지막지하게 올라가게 된다.

JS는 매우 유연한(very flexible) 언어이다. 즉, 개발자가 멍청하고 정신나간 코드를 작성하더라도 JS는 즉각적인 에러로 개발자를 혼내주지않고, 너그러운 마음으로 개발자를 이해하기 때문에 어떻게든 코드를 실행한다는 점이다. 이런 JS의 특징은 언뜻 보면 좋아보일 수도 있겠다. 근데 이는 오히려 개발자를 혼란에 빠뜨리는 JS의 치명적인 단점이다.

아래 예시는 JS로 프로젝트를 구현할 때 실제로 자주 접할 수 있는 경우이다.

```js
const minus = (a, b) => a - b

minus(3, 2) // 1
minus('hello, world') // NaN
minus(3) // NaN
```

개발자가 함수 `minus` 를 작성할 때, 당연히 `a`, `b` 라는 2개의 `number` 타입의 인자를 받을 것이라고 가정하였을 것이다. 하지만 위의 호출 예시처럼 최초 의도와 달리 인자로 `string` 이 들어오거나, 인자가 2개가 아닌 경우에도 JS는 절대 에러를 띄우지 않는다. 어떻게든 코드를 실행시킨다.

위의 예시보다도 더 무서운 건 바로 **런타임 에러**이다. console에서 확인 가능한 런타임 에러는 production 환경에서 발생하는 에러이다. 즉, 개발자 뿐만 아니라 실제 고객 또한 마주할 수 있는 에러이다. JS는 런타임 에러가 발생하기 정말 정말 쉽다. 이는 매우 좋지 못하다.

아래 예시를 보자.

```js
const player = {
  name: 'hira',
  age: 23,
}

player.getFullName() // TypeError: player.getFullName is not a function
```

객체 `player` 에 존재하지 않는 메서드인 `getFullName` 을 호출하는 코드를 작성해도 JS는 그 어떠한 에러도 띄우지 않는다. 결국 이 코드는 그대로 실행되고 이후 발생하는 에러는 그대로 유저에게 보여지게 된다. 정말 최악의 타이밍에 발생하는 에러라고 할 수 있겠다.

이처럼 JS는 런타임 에러가 발생하기 정말 쉽다. <u>개발자라면 코드가 실행되기 전에 에러를 잡아서 유저가 불쾌한 경험을 접하지 않도록 하고 싶을 것</u>이다. 이를 위해서 **Typescript**를 사용한다!
